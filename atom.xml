<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jashion.github.io</id>
    <title>Gridea</title>
    <updated>2023-03-27T03:29:06.440Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jashion.github.io"/>
    <link rel="self" href="https://jashion.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jashion.github.io/images/avatar.png</logo>
    <icon>https://jashion.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[123]]></title>
        <id>https://jashion.github.io/post/123/</id>
        <link href="https://jashion.github.io/post/123/">
        </link>
        <updated>2023-03-27T03:09:18.000Z</updated>
        <content type="html"><![CDATA[<p>123</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Some App Tech Support]]></title>
        <id>https://jashion.github.io/post/some-app-tech-support/</id>
        <link href="https://jashion.github.io/post/some-app-tech-support/">
        </link>
        <updated>2023-03-27T02:27:21.000Z</updated>
        <content type="html"><![CDATA[<p>BMuSimpleCalculator:<br>
The BMuSimpleCalculator is a simple calculator which has addition, subtraction, mutiplication and division features.<br>
<img src="https://jashion.github.io/post-images/1679884104337.png" alt="" loading="lazy"><br>
Getting Support:<br>
mail:ycyz138258886@gmail.com<br>
or leave comment below.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Privacy Policy]]></title>
        <id>https://jashion.github.io/post/privacy-policy/</id>
        <link href="https://jashion.github.io/post/privacy-policy/">
        </link>
        <updated>2023-03-25T08:25:13.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Privacy Policy</strong></p>
<p>HuangJinHua built the BMuSimpleCalculator app as a Free app. This SERVICE is provided by HuangJinHua at no cost and is intended for use as is.</p>
<p>This page is used to inform visitors regarding my policies with the collection, use, and disclosure of Personal Information if anyone decided to use my Service.</p>
<p>If you choose to use my Service, then you agree to the collection and use of information in relation to this policy. The Personal Information that I collect is used for providing and improving the Service. I will not use or share your information with anyone except as described in this Privacy Policy.</p>
<p>The terms used in this Privacy Policy have the same meanings as in our Terms and Conditions, which are accessible at BMuSimpleCalculator unless otherwise defined in this Privacy Policy.</p>
<p><strong>Information Collection and Use</strong></p>
<p>For a better experience, while using our Service, I may require you to provide us with certain personally identifiable information. The information that I request will be retained on your device and is not collected by me in any way.</p>
<p>The app does use third-party services that may collect information used to identify you.</p>
<p>Link to the privacy policy of third-party service providers used by the app</p>
<ul>
<li><a href="https://www.google.com/policies/privacy/">Google Play Services</a></li>
</ul>
<p><strong>Log Data</strong></p>
<p>I want to inform you that whenever you use my Service, in a case of an error in the app I collect data and information (through third-party products) on your phone called Log Data. This Log Data may include information such as your device Internet Protocol (“IP”) address, device name, operating system version, the configuration of the app when utilizing my Service, the time and date of your use of the Service, and other statistics.</p>
<p><strong>Cookies</strong></p>
<p>Cookies are files with a small amount of data that are commonly used as anonymous unique identifiers. These are sent to your browser from the websites that you visit and are stored on your device's internal memory.</p>
<p>This Service does not use these “cookies” explicitly. However, the app may use third-party code and libraries that use “cookies” to collect information and improve their services. You have the option to either accept or refuse these cookies and know when a cookie is being sent to your device. If you choose to refuse our cookies, you may not be able to use some portions of this Service.</p>
<p><strong>Service Providers</strong></p>
<p>I may employ third-party companies and individuals due to the following reasons:</p>
<ul>
<li>To facilitate our Service;</li>
<li>To provide the Service on our behalf;</li>
<li>To perform Service-related services; or</li>
<li>To assist us in analyzing how our Service is used.</li>
</ul>
<p>I want to inform users of this Service that these third parties have access to their Personal Information. The reason is to perform the tasks assigned to them on our behalf. However, they are obligated not to disclose or use the information for any other purpose.</p>
<p><strong>Security</strong></p>
<p>I value your trust in providing us your Personal Information, thus we are striving to use commercially acceptable means of protecting it. But remember that no method of transmission over the internet, or method of electronic storage is 100% secure and reliable, and I cannot guarantee its absolute security.</p>
<p><strong>Links to Other Sites</strong></p>
<p>This Service may contain links to other sites. If you click on a third-party link, you will be directed to that site. Note that these external sites are not operated by me. Therefore, I strongly advise you to review the Privacy Policy of these websites. I have no control over and assume no responsibility for the content, privacy policies, or practices of any third-party sites or services.</p>
<p><strong>Children’s Privacy</strong></p>
<p>These Services do not address anyone under the age of 13. I do not knowingly collect personally identifiable information from children under 13 years of age. In the case I discover that a child under 13 has provided me with personal information, I immediately delete this from our servers. If you are a parent or guardian and you are aware that your child has provided us with personal information, please contact me so that I will be able to do the necessary actions.</p>
<p><strong>Changes to This Privacy Policy</strong></p>
<p>I may update our Privacy Policy from time to time. Thus, you are advised to review this page periodically for any changes. I will notify you of any changes by posting the new Privacy Policy on this page.</p>
<p>This policy is effective as of 2023-03-25</p>
<p><strong>Contact Us</strong></p>
<p>If you have any questions or suggestions about my Privacy Policy, do not hesitate to contact me at ycyz138258886@qq.com.</p>
<p>This privacy policy page was created at <a href="https://privacypolicytemplate.net">privacypolicytemplate.net</a> and modified/generated by <a href="https://app-privacy-policy-generator.nisrulz.com/">App Privacy Policy Generator</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS观察者模式]]></title>
        <id>https://jashion.github.io/post/ios-guan-cha-zhe-mo-shi/</id>
        <link href="https://jashion.github.io/post/ios-guan-cha-zhe-mo-shi/">
        </link>
        <updated>2019-05-15T07:19:26.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="kvc与kvo简介">KVC与KVO简介</h2>
<ul>
<li>KVC<br></li>
</ul>
<blockquote>
<p>KVC（Key-value coding）是一种间接更改对象状态的方式。<br><br>
 官方文档描述：<br><br>
 Key-value coding is a mechanism for accessing an  object’s properties indirectly, using strings to identify properties, rather than through invocation of an accessor method or accessing them directly through instance variables. In essence, key-value coding defines the patterns and method signatures that your application’s accessor methods implement.</p>
</blockquote>
]]></summary>
        <content type="html"><![CDATA[<h2 id="kvc与kvo简介">KVC与KVO简介</h2>
<ul>
<li>KVC<br></li>
</ul>
<blockquote>
<p>KVC（Key-value coding）是一种间接更改对象状态的方式。<br><br>
 官方文档描述：<br><br>
 Key-value coding is a mechanism for accessing an  object’s properties indirectly, using strings to identify properties, rather than through invocation of an accessor method or accessing them directly through instance variables. In essence, key-value coding defines the patterns and method signatures that your application’s accessor methods implement.</p>
</blockquote>
<!--more-->
<ul>
<li>KVC的作用<br></li>
</ul>
<blockquote>
<p>通过键值的方式访问对象或者修改对象的值<br><br>
 比如：NSString *name = [car valueForKey: @&quot;name&quot;];通过-valueForKey:获取对象，它会先查找以参数名命名（格式为-key或-isKey）的getter方法，对于上面的调用，valueForKey:会先寻找-name方法。如果没有这样的getter方法，它将会在对象内寻找名称格式为_key或key的实例变量。通过使用KVC，没有相关getter方法也能获取对象，不需要通过对象指针来直接访问实例变量。</p>
</blockquote>
<p> 
<ul>
<li>KVC的优缺点<br></li>
</ul>
<blockquote>
<p>1.KVC可以轻松处理集合类。（如：NSArray）<br><br>
 2.KVC没有相关getter方法也能获取对象，不需要通过对象指针来直接访问实例变量<br><br>
 3.简化代码<br><br>
 4.KVC需要解析字符串，速度比较慢<br><br>
 5.编译器无法进行错误检查<br></p>
</blockquote>
<ul>
<li>KVO<br></li>
</ul>
<blockquote>
<p>KVO（Key-value Observing）是基于KVC的，一种监听方式，也就是所谓的观察者模式。<br><br>
 官方文档描述：<br><br>
 Key-value observing provides a mechanism that allows objects to be notified of changes to specific properties of other objects. It is particularly useful for communication between model and controller layers in an application.</p>
</blockquote>
<h2 id="kvc代码实现">KVC代码实现</h2>
<pre><code>//1.setValue: forKey
[car setValue: @&quot;奔驰&quot; forKey: @&quot;name&quot;];
[car setValue: [NSNumber numberWithFloat: 80] forKey: @&quot;speed&quot;];
[car setValue: @&quot;黑色&quot; forKey: @&quot;carPaint&quot;];

//1.valueForKey
NSString *name = [currentCar valueForKey: @&quot;name&quot;];
NSNumber *speed = [currentCar valueForKey: @&quot;speed&quot;];
NSString *carPaint = [currentCar valueForKey: @&quot;carPaint&quot;];

//2.setValue:forKeyPath
[car setValue: [NSNumber numberWithFloat: 40] forKeyPath: @&quot;engine.horsepower&quot;];
self.showCarDetail.text = [self showCarDetail: car];

//2.valueForKeyPath
NSNumber *horsepower = [currentCar valueForKeyPath: @&quot;engine.horsepower&quot;];

//3.整体操作:访问数组，如果使用某个键值来访问一个NSArray数组，它实际上会查询相应数组中的每个对象，然后将查询结果大包到另一个数组并返回，但是不能直接在建路径中索引这些数组，如：tires[0].pressure
NSArray *pressures = [currentCar valueForKeyPath: @&quot;tires.pressure&quot;];
NSLog(@&quot;%@&quot;, pressures);

//4.快速运算@count,@sum,@avg,@min,@max,@distinctUnionOfObjects
NSNumber *count = [currentCar valueForKeyPath: @&quot;tires.@count&quot;];    //对左边键值返回数组操作，获取数组数量
NSNumber *sum = [currentCar valueForKeyPath: @&quot;tires.@sum.pressure&quot;];    //对左边键值返回数组操作，获取每个数组里面的pressure值，求和
NSNumber *avg = [currentCar valueForKeyPath: @&quot;tires.@avg.pressure&quot;];    //对左边键值返回数组操作，获取每个数组里面的pressure值，求平均值
NSNumber *min = [currentCar valueForKeyPath: @&quot;tires.@min.pressure&quot;];    //对左边键值返回数组操作，获取每个数组里面的pressure值，找出最小值
NSNumber *max = [currentCar valueForKeyPath: @&quot;tires.@max.pressure&quot;];    //对左边键值返回数组操作，获取每个数组里面的pressure值，找出最大值
NSArray *tireType = [currentCar valueForKeyPath: @&quot;tires.@distinctUnionOfObjects.pressure&quot;];    //对左边键值返回数组操作，获取每个数组里面的pressure值，去掉重复的值，返回一个包含所有不重复值的数组
NSLog(@&quot;TiresCount: %@ Sum: %@, Avg: %@, Min: %@, Max: %@, TireType: %@&quot;, count, sum, avg, min, max, tireType);

//5.批处理
//字典里面不能为nil，如果返回值有nil，则KVC会自己处理，将返回[NSNull null]表示nil
//&lt;null&gt;和(null)的区别：前者是[NSNull null]对象，而后者是正真的nil。
NSArray *keys = [NSArray arrayWithObjects: @&quot;make&quot;, @&quot;modelYear&quot;, @&quot;numberOfDoors&quot;, nil];
NSDictionary *carValues = [currentCar dictionaryWithValuesForKeys: keys];
NSLog(@&quot;%@&quot;, carValues);
    
//6.nil处理
//可以自己运行一下，重写和没有重写setNilValueForKey:方法的代码
[currentCar setValue: nil forKey: @&quot;speed&quot;];
NSLog(@&quot;carSpeed: %@&quot;, [currentCar valueForKey: @&quot;speed&quot;]);
    
//7.处理未定义的值
[currentCar setValue: [NSNumber numberWithFloat: 1500] forKey: @&quot;mileage&quot;];
[currentCar setValue: [NSNull null] forKey: @&quot;price&quot;];
[currentCar setValue: nil forKey: @&quot;capacity&quot;];
NSLog(@&quot;Mileage: %@ Price: %@, Capacity: %@&quot;, [currentCar valueForKey: @&quot;mileage&quot;], [currentCar valueForKey: @&quot;price&quot;], [currentCar valueForKey: @&quot;capacity&quot;]);

//8.KVC有自动装箱的功能，当使用valueForKey时，它自动将标量值（int,float,struct...）放入NSNumber或NSValue中；当使用setValueForKey，它自动将标量值从这些对象取出。

</code></pre>
<h2 id="kvo代码实现">KVO代码实现</h2>
<pre><code>//应该在监听者里添加监听，而不是在被监听者里添加监听
//在被监听者添加监听会造成循环引用的问题
car = [[Car alloc] init];
[car addObserver: self forKeyPath: @&quot;carPaint&quot; options: NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context: nil];

- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context {
    if ([keyPath isEqualToString: @&quot;carPaint&quot;]) {
        NSLog(@&quot;%@&quot;, [change objectForKey: @&quot;new&quot;]);    //修改之后的值
        self.showCarDetail.text = [NSString stringWithFormat: @&quot;车的颜色是%@&quot;, [change objectForKey: @&quot;new&quot;]];
    }
}

- (void)dealloc {
    //监听者应该是self，被监听者是car
    [car removeObserver: self forKeyPath: @&quot;carPaint&quot;];
}

</code></pre>
<h2 id="demo展示br">Demo展示：<br></h2>
<figure data-type="image" tabindex="1"><img src="http://jashion.b0.upaiyun.com/images/iOSObserving.gif" alt="Observer.gif" loading="lazy"></figure>
<p><a href="https://github.com/jashion/iOSObserving">Demo下载</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[iOS的图片框架]]></title>
        <id>https://jashion.github.io/post/ios-de-tu-pian-kuang-jia/</id>
        <link href="https://jashion.github.io/post/ios-de-tu-pian-kuang-jia/">
        </link>
        <updated>2019-05-15T06:42:13.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>今年五月份进的新公司，接手的第一个新项目，里面我主要负责发帖，具体是图文，不包括视频。由于时间紧急，开发时间只有3天，实际上包括开发，测试和修复BUG，用了差不多3周的时间，第一周开发完成基本功能，后面两周测试和修复BUG,由于当时没有做过相册相关的功能，也因为时间紧急，所以，使用了一个<a href="https://github.com/zhuochenming/ImagePickerController">第三方的库</a>，大家可以去看一下，写的比较全面。后来，项目完成之后，终于有时间，静下心慢慢研究iOS的图片框架了，个人对于不懂的东西，好奇心和求知欲还是比较强的。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>今年五月份进的新公司，接手的第一个新项目，里面我主要负责发帖，具体是图文，不包括视频。由于时间紧急，开发时间只有3天，实际上包括开发，测试和修复BUG，用了差不多3周的时间，第一周开发完成基本功能，后面两周测试和修复BUG,由于当时没有做过相册相关的功能，也因为时间紧急，所以，使用了一个<a href="https://github.com/zhuochenming/ImagePickerController">第三方的库</a>，大家可以去看一下，写的比较全面。后来，项目完成之后，终于有时间，静下心慢慢研究iOS的图片框架了，个人对于不懂的东西，好奇心和求知欲还是比较强的。</p>
<!--more-->
<h2 id="一ios8以前的assetslibrary框架">一.iOS8以前的AssetsLibrary框架</h2>
<p>我感觉，AssetsLibrary框架还是比较好用的，不过iOS9以后就被弃用了，使用iOS8出来的Photos框架，相比于AssetsLibrary更为强大，效率更高。具体的<a href="https://developer.apple.com/library/ios/documentation/AssetsLibrary/Reference/ALAssetsLibrary_Class/">文档</a>可以去苹果官方浏览，这里只详述自己研究的一些东西。<br>
AssetsLibrary框架只有6个文件，非常简洁：</p>
<pre><code>//该文件主要作用是引进头文件
AssetsLibrary.h 

//所有照片和视频的集合
ALAssetsLibrary.h  

//代表一张图片或者一个视频的元数据
ALAsset.h  

//代表ALAsset对象包含的一些数据，比如：url，filename等等。
ALAssetRepresentation.h

//过滤器：1.图片 2.视频 3.全部
ALAssetsFilter.h

//assets的集合，比如：相册
ALAssetsGroup.h
</code></pre>
<p>下面讲解主要用到的一些操作：</p>
<h3 id="1iphone手机在获取本地相册和视频的时候需要得到本人的许可认证所以第一步是获取判断认证状态">1.iPhone手机在获取本地相册和视频的时候，需要得到本人的许可认证，所以，第一步是获取判断，认证状态。</h3>
<pre><code>//ALAuthorizationStatusNotDetermined  //用户还没做出选择
//ALAuthorizationStatusRestricted  	  //用户受到某些限制，不能自己决定，比如：家长控制
//ALAuthorizationStatusDenied	      //用户明确否决
//ALAuthorizationStatusAuthorized     //用户认证通过

[ALAssetsLibrary authorizationStatus] == ALAuthorizationStatusAuthorized
//判断状态是否是准许，如果允许则可以获取本地相册，否则，不能获取，则可以提示需要用户做什么操作才能打开本地相册
</code></pre>
<h3 id="2获取本地相册以及相册相关的一些信息比如缩略图相册名称等等">2.获取本地相册，以及相册相关的一些信息，比如：缩略图，相册名称等等。</h3>
<pre><code>//1.获取相册
@property (nonatomic, strong) ALAssetsLibrary *assetsLibrary;  //ALAssetsLibrary实例必须被controller强引用或者是实例变量，不然会报错

[self.assetsLibrary enumerateGroupsWithTypes: ALAssetsGroupAll usingBlock:^(ALAssetsGroup *group, BOOL *stop) {
    ALAssetsFilter *onlyPhotosFilter = [ALAssetsFilter allPhotos];  //过滤器，只获取图片
    [group setAssetsFilter: onlyPhotosFilter];
            
    if ([group numberOfAssets] &gt; 0) {    //当group＝nil是就是遍历完全部相册
        [albumsArray addObject: [self modelWithAssetResult: group name: [group valueForProperty: ALAssetsGroupPropertyName]]];
    } else {
        completion(albumsArray);
    }
    //*stop=NO(停止遍历照片数组)
} failureBlock:^(NSError *error) {
    NSString *errorMessage = nil;
    switch ([error code]) {    //错误代码的处理
        case ALAssetsLibraryAccessUserDeniedError:
        case ALAssetsLibraryAccessGloballyDeniedError:
             errorMessage = @&quot;The user has declined access to it.&quot;;
             break;
                    
        default:
             errorMessage = @&quot;Reason unknow.&quot;;
             break;
        }
        NSLog(@&quot;%@&quot;, errorMessage);
}];


//说一下Group Type
ALAssetsGroupSavedPhotos  //Camera Roll
ALAssetsGroupPhotoStream  //My Photo Stream
ALAssetsGroupAll				//All  available group
//剩下的类型可以去看文档


//2.获取相册的缩略图
ALAssetsGroup *group = (ALAssetsGroup *)model.assetResult;
CGImageRef posterImageRef = [group posterImage];
UIImage *posterImage = [UIImage imageWithCGImage: posterImageRef];

//3.遍历相册获取每一个相片或者视频的asset
//有3个遍历相册的方法，其中Result代表一张照片或者一个视频，stop是停止遍历的标识，默认为NO，如果stop=YES，则停止下一次的遍历

//(1).顺序遍历，同步遍历
[self.albumGroup enumerateAssetsUsingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        [self.albumPhotos addObject: result];
    }
}];

//(2).并发遍历或者逆序遍历
//NSEnumerationConcurrent: 并发不保证顺序
//NSEnumerationReverse: 逆序遍历
[self.albumGroup enumerateAssetsWithOptions: NSEnumerationConcurrent usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        [self.albumPhotos addObject: result];
    }
}];


//(3).可选择遍历的位置和并发或者逆序遍历
//获取0～9下标的照片
NSRange range = {0, 10};
[self.albumGroup enumerateAssetsAtIndexes: [NSIndexSet indexSetWithIndexesInRange: range] options: NSEnumerationConcurrent usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        [self.albumPhotos addObject: result];
    }
}];

//获取下标为10的照片
NSIndexSet *indexSet = [NSIndexSet indexSetWithIndex: 9];
[self.albumGroup enumerateAssetsAtIndexes: indexSet options: NSEnumerationConcurrent usingBlock:^(ALAsset *result, NSUInteger index, BOOL *stop) {
    if (result) {
        [self.albumPhotos addObject: result];
    }
}];

//4.获取照片的缩略图
ALAsset *asset = self.albumPhotos[indexPath.row];
CGImageRef thumdnailImageRef = [asset thumbnail];  //[asset aspectRatioThumbnail]

//5.获取照片
ALAsset *photoAsset = (ALAsset *)asset;
ALAssetRepresentation *assetRepresentation = [photoAsset defaultRepresentation];    //ALAssetRepresentation获取asset的一些相关的参数，一个asset可以拥有多个ALAssetRepresentation
CGImageRef photoRef = [assetRepresentation fullScreenImage];    //fullScreenImage全屏照片，包含编辑过的信息，是一张缩略图；
CGImageRef photoRef = [assetRepresentation fullResolutionImage]    //fullResolutionImage图片原图，不包含编辑过的信息，是一张高清图，加载比较慢
//- (CGImageRef)CGImageWithOptions:(NSDictionary *)options  根据参数获取图片，当options=nil则和fullResolutiongImage等同

//如果是fullScreenImage，可以使用下面两种方法获取图片，但建议使用第二种，因为有些照片有旋转方向问题，旋转方向选择默认UIImageOrientationUp类型就好
//如果是fullResolutionImage，旋转方向使用assetRepresentation.orientation，则显示出来的图片就不会有旋转方向问题
UIImage *resultImage = [UIImage imageWithCGImage: photoRef];
UIImage *resultImage = [UIImage imageWithCGImage: photoRef
                                           scale: [assetRepresentation scale]
                                     orientation: UIImageOrientationUp];
                                     


//6.其它方法
//创建相册
- (void)addAssetsGroupAlbumWithName:(NSString *)name resultBlock:(ALAssetsLibraryGroupResultBlock)resultBlock failureBlock:(ALAssetsLibraryAccessFailureBlock)failureBlock；

//保存照片或视频到相册(保存在Camera Roll和My Photo Stream)
- (void)writeImageToSavedPhotosAlbum:(CGImageRef)imageRef orientation:(ALAssetOrientation)orientation completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock 
- (void)writeImageToSavedPhotosAlbum:(CGImageRef)imageRef metadata:(NSDictionary *)metadata completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock 
- (void)writeImageDataToSavedPhotosAlbum:(NSData *)imageData metadata:(NSDictionary *)metadata completionBlock:(ALAssetsLibraryWriteImageCompletionBlock)completionBlock 

- (void)writeVideoAtPathToSavedPhotosAlbum:(NSURL *)videoPathURL completionBlock:(ALAssetsLibraryWriteVideoCompletionBlock)completionBlock

//相册内容改变的通知
ALAssetsLibraryChangedNotification

//添加到相应的相册，可以在获取该相册的ALAssetsGroup，调用addAsset方法
- (BOOL)addAsset:(ALAsset *)asset    //不过没有找到将一张图片变成asset的方法，只能先保存在Camera Roll/My Photo Stream然后获得该图片的asset再保存在特定的相册，不过由于是同一个asset，所以，一旦删除一个，所有相册中的这张图片都会被删除

</code></pre>
<h3 id="3据说是一些坑点">3.据说是一些坑点</h3>
<ul>
<li>
<p>ALAssetsLibrary实例必须被controller强引用或者是实例变量，不然会报错。(已亲自试验，会报错。)</p>
</li>
<li>
<p>AssetsLibrary 遵循写入优先原则。(<a href="http://kayosite.com/ios-development-and-detail-of-photo-framework.html">原帖出处</a>，没有试验过。)<br>
AssetsLibrary 读取资源的过程中，有任何其它的进程（不一定是同一个 App）在保存资源时，就会收到 ALAssetsLibraryChangedNotification，让用户自行中断读取操作。最常见的就是读取 fullResolutionImage 时，这时候再在别的进程写入，由于读取 fullResolutionImage 耗时较长，很容易就会 exception。</p>
</li>
<li>
<p>开启 Photo Stream 容易导致 exception。(<a href="http://kayosite.com/ios-development-and-detail-of-photo-framework.html">原帖出处</a>，没有试验过。)<br>
如果用户开启了共享照片流（Photo Stream），共享照片流会以 mstreamd 的方式“偷偷”执行，当有人把相片写入 Camera Roll 时，它就会自动保存到 Photo Stream Album 中，如果用户刚好在读取，那就跟上面说的一样产生 exception 了。由于共享照片流是用户决定是否要开启的，所以开发者无法改变，但是可以通过下面的接口在需要保护的时刻关闭监听共享照片流产生的频繁通知信息。<br>
保护措施：</p>
<pre><code>[ALAssetsLibrary disableSharedPhotoStreamsSupport];  //禁止图片共享
</code></pre>
</li>
</ul>
<h2 id="二ios8以后使用更为强大的photos框架">二.iOS8以后，使用更为强大的Photos框架</h2>
<p>Photos框架包括两个库Photos和PhotoUI，而PhotoUI主要是用来显示iOS9新增的Photo类型，LivePhoto说白了就是苹果新增的GIF,不过只能在iphone6以后发布的机型拍摄LivePhoto，下面也会介绍到这个新的图片类型。Let's begin!<br>
Photos库比ALAssetLibrary库复杂很多，相对的，功能强大很多，下面简述一下各个文件的作用：</p>
<h4 id="tips-升级ios10之后需要把在plist文件中添加所用的隐私权限比如本应用获取相机权限获取本地相册权限获取本地视频权限等等不然后crash掉没得商量苹果依然霸道如初">Tips: 升级iOS10之后，需要把在plist文件中添加所用的隐私权限，比如本应用：获取相机权限，获取本地相册权限，获取本地视频权限等等，不然后Crash掉，没得商量，苹果依然霸道如初。</h4>
<h3 id="1interacting-with-the-photos-library与photos库的交互">1.Interacting with the Photos Library(与Photos库的交互)</h3>
<pre><code>PHPhotoLibrary
\\获取系统相册授权以及监听系统相册的变化，包括创建，删除和编辑
\\由于PHAsset,PHAssetCollection和PHCollectionList是不可变对象
\\所以，系统在该文件提供了一个修改系统相册资源的Block
</code></pre>
<h3 id="2retrieving-and-examining-assets检索获取和审查assets">2.Retrieving and Examining Assets(检索，获取和审查Assets)</h3>
<pre><code>PHAsset
\\代表系统的一个图片，视频或者Live Photo

PHAssetCollection
\\代表一组Photos asset，比如：系统相册里的时刻一个分类，用户创建的相册或者智能相册

PHCollectionList
\\代表一组包含一个或者多个Photos asset collection，比如：时刻里的年或者包含用户创建的一个或者多个相册

PHCollection
\\一个抽象类，是PHAssetCollection和PHColletionList的父类

PHObject
\\Photos model objects(assets和collections)的抽象类

PHFetchResult
\\包含assets或者collections有序的一系列集合

PHFetchOptions
\\option的集合，关于过滤，排序和管理Photos
</code></pre>
<h3 id="3loading-asset-content">3.Loading Asset Content</h3>
<pre><code>PHImageManager
\\提供获取或生成预览的缩略图和原图或者视频的数据

PHCachingImageManager
\\提供获取或生成预览的缩略图和原图或者视频的数据
\\和PHImageManager不同之处在于可以缓存图片，并且如果有缓存则直接从缓存取数据

PHImageRequestQptions
\\获取图片的一些参数设置

PHVideoRequestOptions
\\获取视频的一些参数设置

PHLivePhotoRequestOptions
\\获取Live Photo的一些参数设置

PHLivePhoto
\\展示Live Photo(包含动作和声音的图片集合，和GIF差不多)
</code></pre>
<h3 id="4requesting-changes">4.Requesting Changes</h3>
<pre><code>PHAssetChangeRequest
\\在photo library change block里创建，删除，修改metadata或者编辑Photos asset的内容的request

PHAssetCollectionChangeRequest
\\在photo library change block里创建，删除或者修改Photos asset collection的request

PHCollectionListChangeRequest
\\在photo library change block里创建，删除或者修改Photos collection list的request

PHObjectPlaceholder
\\Photos asset和Photo collection的唯一资源占位符
</code></pre>
<h3 id="5editing-asset-content">5.Editing Asset Content</h3>
<pre><code>PHContentEditingInput
\\一个提供编辑资源(image,video,Live Photo)信息的容器

PHContentEditingOutput
\\一个包含编辑资源(image,video,Live Photo)结果的容器

PHAdjustmentData
\\包含编辑资源的描述，可以允许恢复编辑之前的状态

PHContentEditingInputRequestOptions
\\编辑资源的options

PHLivePhotoEditingContext
\\Live Photo编辑的环境

PHLivePhotoFrame
\\一个Live Photo的frame

</code></pre>
<h3 id="6observing-changes监听系统相册资源的改变">6.Observing Changes(监听系统相册资源的改变)</h3>
<pre><code>PHPhotoLibraryChangeObserver
\\监听协议

PHChange
\\Photos library改变的描述

PHObjectChangeDetails
\\asset或者collection对象改变的描述

PHFetchResultChangeDetails
\\一系列asset或者collection对象改变的描述

</code></pre>
<h3 id="7working-with-asset-resources">7.Working with Asset Resources</h3>
<pre><code>PHAssetResource
\\图片，视频和Live Photo在Photos library里的基础数据

PHAssetCreationRequest
\\使用基础数据创建新的Photos asset

PHAssetResourceCreationOptions
\\使用基础数据创建新的Photos asset的一些设置

PHAssetResourceManager
\\提供关于Photos asset基础数据的储存方法

PHAssetResourceRequestOptions
\\获取基础数据的一些设置

</code></pre>
<h3 id="8media-types-and-subtypes">8.Media Types and Subtypes</h3>
<pre><code>PHAssetMediaType
\\媒体类型，比如：图片，视频，LivePhoto

PHAssetMediaSubtype
\\asset media，比如：全景照片，截屏，延时拍摄，慢动作等等

</code></pre>
<h3 id="9structures">9.Structures</h3>
<pre><code>PHAssetBurstSelectionType
PHAssetSourceType
PHLivePhotoEditingOption
</code></pre>
<h3 id="10other-reference">10.Other Reference</h3>
<pre><code>Photos Constants
Photos Enumerations
Photos Data Types
</code></pre>
<h3 id="11下面介绍和功能相关的实现代码">11.下面介绍和功能相关的实现代码</h3>
<pre><code>1.首先获取用户权限
[PHPhotoLibrary authorizationStatus] == PHAuthorizationStatusAuthorized
//判断用户是否允许获取本地相册
//和ALAsslibrary返回的状态一致，具体可以到PHPhotoLibrary头文件去查看

2.获取本地相册集合
//相册，在这里抽象成了文件夹的概念，使用PHAssetCollection来表示
//时刻使用PHCollectionList来表示
//PHCollection既可以表示一个相册或者一个时刻，可以表示多个相册的集合以及集合里面还可以嵌套文件夹
//获取相册有关的函数都在PHCollection头文件里面，感兴趣的可以去看一下
//这里只用到的相册部分

//获取职能相册，即系统创建的相册
PHFetchResult *smartAlbums = [PHAssetCollection fetchAssetCollectionsWithType: PHAssetCollectionTypeSmartAlbum subtype: PHAssetCollectionSubtypeAlbumRegular options: nil];

//获取用户相册，即用户创建的相册，包括用户自己创建和App创建的相册
PHFetchResult *albums = [PHAssetCollection fetchAssetCollectionsWithType: PHAssetCollectionTypeAlbum subtype: PHAssetCollectionSubtypeAlbumRegular | PHAssetCollectionSubtypeAlbumMyPhotoStream options: nil];

//PHAssetCollectionType有三种类型：
//PHAssetCollectionTypeAlbum相册（用户），PHAssetCollectionTypeSmartAlbum智能相册（系统），PHAssetCollectionTypeMoment时刻
//PHAssetCollectionSubType有很多类型，比如：视频，全景照片，自拍等等，具体什么类型代表哪个相册，有兴趣的自行去查看

3.获取相册里面的资源，包括照片和视频
//一张图片和一个视频都是使用PHAsset来表示

//option选择过滤
PHFetchOptions *option = [[PHFetchOptions alloc] init];
if (!allowPickingVideo) {
	option.predicate = [NSPredicate predicateWithFormat: @&quot;mediaType == %ld&quot;, PHAssetMediaTypeImage];    //过滤掉视频
}
option.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey: @&quot;creationDate&quot; ascending: YES]];    //按照创建时间升序
PHFetchResult *fetchResult = [PHAsset fetchAssetsInAssetCollection: albumCollection options: option];
PHFetchResult *allPhotos = [PHAsset fetchAssetsWithOptions: option];    //获取所有资源

4.获取照片，LivePhoto或者视频
//Notice: LivePhoto也是属于图片类型

//获取图片需要指定大小
//如果指定的大小的高宽比和图片的高宽比不一致，则contentMode决定返回图片的尺寸
//contentMode有三种类型：
//PHImageContentModeAspectFit（等比例适应），PHImageContentModeAspectFill（等比例缩放适应），
PHImageContentModeDefault（默认，相当于第一种）
//可以设置为PHImageManagerMaximumSize大小，获取原图或者最大的图片尺寸，但是会忽略option里面的resizeMode的设置
//option相关选择过滤设置，比较重要的如下
//PHImageRequestOptionsDeliveryMode决定返回的图片质量
//networkAccessAllowed默认为NO，设为YES则可以通过网络从iClould下载图片
//synchronous是否为同步操作，默认为NO，如果设置为YES则，相关模式下只会返回一张图片
//回调里面的字典，包含这张图片相关的metaData，比如：滤镜，帖子什么的
[[PHImageManager defaultManager] requestImageForAsset: phAsset
                                                   targetSize: CGSizeMake(resultImageWidth, resultImageHeight)
                                                  contentMode: PHImageContentModeAspectFill
                                                      options: nil
                                                resultHandler:^(UIImage * _Nullable result, NSDictionary * _Nullable info) {
            BOOL downloadFinished = (![[info objectForKey: PHImageCancelledKey] boolValue] &amp;&amp; ![info objectForKey: PHImageErrorKey]);
            if (downloadFinished &amp;&amp; result) {
                if (completion) {
                    completion(result, info, [[info objectForKey: PHImageResultIsDegradedKey] boolValue]);
                }
            }
            
            // Download image from iCloud
            if ([[info objectForKey: PHImageResultIsInCloudKey] boolValue] &amp;&amp; !result) {
                 PHImageRequestOptions *option = [[PHImageRequestOptions alloc] init];
                 option.networkAccessAllowed = YES;
                 [[PHImageManager defaultManager] requestImageDataForAsset: asset
                                                     options: option
                                               resultHandler:^(NSData * _Nullable imageData, NSString * _Nullable dataUTI, UIImageOrientation orientation, NSDictionary * _Nullable info) {
                    UIImage *resultImage = [UIImage imageWithData: imageData scale: [UIScreen mainScreen].scale];
                    if (resultImage &amp;&amp; completion) {
                        completion(resultImage, info, [[info objectForKey: PHImageResultIsDegradedKey] boolValue]);
                    }
                 }];
            }
}];

//LivePhoto也是照片
//LivePhoto需要PHLivePhotoView来呈现，具体怎么展现看Demo的代码
//其他和获取照片也差不多
PHLivePhotoRequestOptions *livePhotoOptions = [[PHLivePhotoRequestOptions alloc] init];
livePhotoOptions.deliveryMode = PHImageRequestOptionsDeliveryModeHighQualityFormat;
livePhotoOptions.networkAccessAllowed = YES;
livePhotoOptions.progressHandler = ^(double progress, NSError *error, BOOL *stop, NSDictionary *info){
        dispatch_async(dispatch_get_main_queue(), ^{
            NSLog(@&quot;livePhotoProgress: %lf&quot;, progress);
        });
    };
    
    [[PHImageManager defaultManager] requestLivePhotoForAsset: phAsset targetSize: [UIScreen mainScreen].bounds.size contentMode: PHImageContentModeAspectFit options: livePhotoOptions resultHandler:^(PHLivePhoto * _Nullable livePhoto, NSDictionary * _Nullable info) {
        if (!livePhoto) {
            return ;
        }
        
        if (completion) {
            completion(livePhoto, info);
        }
    }];

//获取视频
PHVideoRequestOptions *options = [[PHVideoRequestOptions alloc] init];
options.networkAccessAllowed = YES;
options.progressHandler = ^(double progress, NSError *__nullable error, BOOL *stop, NSDictionary *__nullable info) {
            dispatch_async(dispatch_get_main_queue(), ^{
                NSLog(@&quot;videoProgress: %lf&quot;, progress);
            });
        };
        [[PHImageManager defaultManager] requestPlayerItemForVideo: asset options: options resultHandler:^(AVPlayerItem * _Nullable playerItem, NSDictionary * _Nullable info) {
            if (playerItem &amp;&amp; completion) {
                completion(playerItem, info);
            }
		}];

5.创建相册，储存图片或者视频，编辑图片，具体看Demo代码，这里就不在废话多说了
</code></pre>
<h2 id="三总结">三.总结</h2>
<p>这边文章很早就开始写了，断断续续写了几个月，一来工作有时忙没有时间，二来主要是自己懒。但是，总的来说，还是写完了，这也是极好的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[UIDynamicAnimator]]></title>
        <id>https://jashion.github.io/post/uidynamicanimator/</id>
        <link href="https://jashion.github.io/post/uidynamicanimator/">
        </link>
        <updated>2019-05-15T06:23:22.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="动力系统what-is-the-uikit-dynamics">动力系统(What is the UIKit Dynamics?)</h2>
<p>动力系统的引入，并不是替代CoreAnimation，而是对模拟现实世界物体运动的补充，比如，碰撞，重力，悬挂等等。所以说，UIKit动力系统的引入，大大简化了一些交互动画（不需要自己实现一些模拟现实世界物理动力系统的动画），丰富了UI设计。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="动力系统what-is-the-uikit-dynamics">动力系统(What is the UIKit Dynamics?)</h2>
<p>动力系统的引入，并不是替代CoreAnimation，而是对模拟现实世界物体运动的补充，比如，碰撞，重力，悬挂等等。所以说，UIKit动力系统的引入，大大简化了一些交互动画（不需要自己实现一些模拟现实世界物理动力系统的动画），丰富了UI设计。</p>
<!-- more --> 
<h2 id="动力系统怎么使用how-to-use-it">动力系统怎么使用(How to use it?)</h2>
<p><strong>UIKit动力系统结构如下：</strong></p>
<figure data-type="image" tabindex="1"><img src="http://jashion.b0.upaiyun.com/images/UIDynamics.png" alt="image" loading="lazy"></figure>
<p>总的来说，先要注册UI系统体系，也就是类似于二维的坐标系，然后添加所需的行为以及行为的作用物体，然后该物体就能在设定的坐标体系里，根据所添加的行为运动。<br><br>
光说不练乃是纸上谈兵，没有成效。<br>
下面分解动力系统所包含的几类运动：</p>
<p><strong>UIGravityBehavior</strong></p>
<p>重力，这个大家应该都很熟悉了。我们每天都能感受到它的存在，所谓脚踏实地就是这种感觉。小时候，大家应该都有过从高处把一些物体扔下来，或者直接让它坐自由落体运动，相似的，这个Gravity也是模拟重力行为，下面直接上代码。</p>
<pre><code>myAnimator = [[UIDynamicAnimator alloc] initWithReferenceView: self];
myAnimator.delegate = self;
UIGravityBehavior *gravityBehavior = [[UIGravityBehavior alloc] initWithItems: @[ball]];
[myAnimator addBehavior: gravityBehavior];

</code></pre>
<p>1.UIDynamicAnimator就是一个播放者，容器。一个容纳动力系统的环境，而referenceView就是该环境的坐标系，物体运动的参照系。<br><br>
2. gravityBehavior，初始化一个重力行为，行为的受力物体是ball（只要实现UIDynamicItem接口的类都能作为受力物体，如，View和UICollectionViewLayoutAttributes）。<br><br>
3. 将这个行为添加到UIDynamicAnimator上面就行了。<br><br>
4. 显示效果的Demo以及代码下载在最后。</p>
<p><strong>UICollisionBehavior</strong></p>
<p>碰撞行为，最直接的感受就是，玩弹珠，一颗弹珠可以被另一颗弹珠弹射到很远的地方，原理就是碰撞产生了一个反方向的作用力，远离事故发生地。废话也不多说，直接上代码：</p>
<pre><code>myAnimator = [[UIDynamicAnimator alloc] initWithReferenceView: self];

UICollisionBehavior *collision = [[UICollisionBehavior alloc] initWithItems: ballsArray2];        collision.translatesReferenceBoundsIntoBoundary = YES;
collision.collisionDelegate = self;
[myAnimator addBehavior: collision];

</code></pre>
<p>1.和重力行为一样，也要先初始化一个容器myAnimator。<br><br>
2.添加碰撞行为collision，collision.translatesReferenceBoundsIntoBoundary的属性是否设置以参考View的边界为碰撞边界，我们这里选择YES。<br><br>
3.除了设置参考View的边界为碰撞边界外，还可以自己设定边界，使用- addBoundaryWithIdentifier: forPath:或者addBoundaryWithIdentifier: fromPoint: toPoint:方法可以自己设定碰撞边界的范围。<br>
4。最后，也需要把collision添加到myAnimator上。</p>
<p><strong>UIAttachmentBehavior</strong></p>
<p>描述一个物体和一个锚点或者另一个物体的连接，可以是弹性的，也可以是非弹性的连接。直接上代码：</p>
<pre><code>UIAttachmentBehavior *attachmentBehavior = [[UIAttachmentBehavior alloc] initWithItem: square offsetFromCenter: UIOffsetMake(0, - 40) attachedToAnchor: anchor];
attachmentBehavior.length = 100;
attachmentBehavior.damping = 0.3;
[myAnimator addBehavior: attachmentBehavior];

</code></pre>
<p>1.物体默认的锚点在中心，可以设置偏移。<br><br>
2.步骤也是和其它得行为一样，设置参数，把该行为添加到myAnimator上。<br><br>
3.更多的方法和属性，请自行参考苹果官方文档。</p>
<p><strong>UISnapBehavior</strong></p>
<p>吸附行为，将UIView通过动画吸附到某个点上。API非常简单，看下面代码就懂了。</p>
<pre><code>UISnapBehavior *snapBehavior = [[UISnapBehavior alloc] initWithItem: ballView snapToPoint: centerBall.center];
snapBehavior.damping = 0.4;
[myAnimator addBehavior: snapBehavior];
</code></pre>
<p><strong>UIPushBehavior</strong></p>
<p>推动力，可以理解为向一个物体施加一个作用力，可以是持续的，也可以是瞬间的冲击。</p>
<pre><code>UIPushBehavior *pushBehavior = [[UIPushBehavior alloc] initWithItems: @[square] mode: UIPushBehaviorModeInstantaneous];
pushBehavior.pushDirection = CGVectorMake(velocity.x / 1000, velocity.y / 1000);
[myAnimator addBehavior: pushBehavior];

</code></pre>
<p><strong>UIDynamicItemBehavior</strong></p>
<p>这其实不是一种行为，我的理解是对于将要进行各种行为的物体一些参数上面的设置，比如，弹力，震荡频率，密度等等。</p>
<pre><code>UIDynamicItemBehavior *behavior3 = [[UIDynamicItemBehavior alloc] initWithItems: @[ballsArray2[2]]];
behavior3.elasticity = 0.5;
behavior3.friction = 0.3;
behavior3.resistance = 0.3;
[myAnimator addBehavior: behavior3];
</code></pre>
<h2 id="组合group">组合(Group)</h2>
<p>所有的行为都可以组合起来，如碰撞和重力，可以类似于物体做自由落体运动，然后和地面碰撞。代码如下：</p>
<pre><code>myAnimator = [[UIDynamicAnimator alloc] initWithReferenceView: self];
//重力行为
UIGravityBehavior *gravity = [[UIGravityBehavior alloc] initWithItems: @[ball]];
[myAnimator addBehavior: gravity];

//碰撞行为
UICollisionBehavior *collision = [[UICollisionBehavior alloc] initWithItems: @[ball]];
collision.translatesReferenceBoundsIntoBoundary = YES;
collision.collisionDelegate = self;
[myAnimator addBehavior: collision];

//设置物体的一些相关的参数
UIDynamicItemBehavior *behavior = [[UIDynamicItemBehavior alloc] init];
behavior.elasticity = 0.8;
behavior.friction = 0.2;
behavior.resistance = 0.3;
behavior.density = 0.5;
behavior.angularResistance = 0.2;
[behavior addItem: ball];
[myAnimator addBehavior: behavior];

</code></pre>
<h2 id="自定义行为diy">自定义行为(DIY)</h2>
<p>1.将官方的行为打包<br></p>
<ul>
<li>继承UIDynamicBehavior(一个抽象类)</li>
<li>实现添加组合行为的方法，最好和官方的保持一致，比如：initWithItems:，在里面调用addChildBehavior：方法添加需要组合的行为</li>
<li>初始化该继承类，然后使用</li>
</ul>
<pre><code>@interface GravityWithCollisionBehavior : UIDynamicBehavior

- (instancetype)initWithItems: (NSArray *)items;

@end

@implementation GravityWithCollisionBehavior

- (instancetype)initWithItems: (NSArray *)items {
    self = [super init];
    if (self) {
        UIGravityBehavior *gravityBehavior = [[UIGravityBehavior alloc] initWithItems: items];
        [self addChildBehavior: gravityBehavior];
        UICollisionBehavior *collisionBehavior = [[UICollisionBehavior alloc] initWithItems: items];
        collisionBehavior.translatesReferenceBoundsIntoBoundary = YES;
        [self addChildBehavior: collisionBehavior];
    }
    return self;
}

@end
</code></pre>
<p>2.完全自定义行为<br><br>
UIDynamicBehavior里提供了一个<code>@property(nonatomic, copy) void (^action)(void)</code>，animator将会在行为发生期间，每一步都调用这个block。也就是说，你想自定义行为就得在这里写自己的一些代码。具体就是在这个block中向所有的item询问它们当前的center和transform状态，然后经过计算，把新的值赋予相应的item，从而该改变它们在屏幕上的位置，大小，角度，方向等等。</p>
<h2 id="总结summary">总结(Summary)</h2>
<p>总的来说，iOS7引进的这套动力系统，大大丰富了我们动画表达，但是，该系统有着一些限制，会消耗一定的CPU资源，并且，当它们被添加到动画系统后，只能通过动画系统改变位置，而外部对于UIDynamicsItem的center,transform等设定是被忽略的，除此之外，该系统也没有现实世界那么精确，当计算迭代无法得到有效解的时候，动画将无法得到正确的呈现，所以，不要将动力系统神化。</p>
<h2 id="demo展示">Demo展示</h2>
<figure data-type="image" tabindex="2"><img src="http://jashion.b0.upaiyun.com/images/UIDynamics.gif" alt="UIDynamicAnimator" loading="lazy"></figure>
<p><a href="https://github.com/jashion/UIDynamicAnimation.git">源码下载</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://jashion.github.io/post/hello-gridea/</id>
        <link href="https://jashion.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>𝖶𝗂𝗇𝖽𝗈𝗐𝗌</strong> 或 <strong>𝖬𝖺𝖼𝖮𝖲</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>